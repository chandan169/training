.net core
-----------
- .Net core version
	- version 1.0
	- version 1.1
	- version 2.0
	- version 2.1
	- version 2.2(LTS long term support)
	- version 3.0(current)
	
- features of .NEt core
	-light weight
	- cross-platform support
	- cli support
	- Support varios IDEs.
	- Support developing console like ASP.net (MVC, web api, SPA) class lib UWP(universal 
		- no web form 
		- no WPF and windows forms
		- no WCF and WF(work flow)
		- in 3.0 version, it is supporting wpf.
	- built in feature of DI system.
		- we can replace Built-in DI system with 3rd party DI system (Autofac).
	- Tag Helpers are used insted of HTML helpwes
		- HTML helpers are not replaced.
		<a action="Index" controller="Home" route-params="" area="" class="nav-item"></a>
	-Razor page in >NET core 2.0
		- Blazor is used in 3.0 version
		
	-Configuratin is JSON based.
	appsetting.json file.
	- NET core can read config parameter   from:
		- Environment vriable
		- command line Argumet.
		JSON file.XML 
		xml files
		ini files
		key value pair
		
	- Application templates
	- console
	-Asp .net
		-MVC 
		Web api
		SPA
	-class library
	-standard libraries can be used with .net Framework and .net core
	-UWP
		
-ASP.net MVC
	- .Net Core web application uses a builtin web server called Kestral.
	- Kestral is a cross-platform light weightweb server
	-Program.cs
		- creates and starts a webhost server.
		-contains a main method that starts the Host for MVC app.
	- type of Host in .net Core
		- WebHost(ASP.NET,  WEB API)
		- Generic host - ther is no HTTP request pipeline, used for WEb jobs
		
	-Startup.cs
		- Configure the services for the application.
		- ConfigureService() method is used to configure the service required in app.
		- Creates a request pipeline for handling request.
			- Configure() method is used to configure the request pipeline.
			- Request pipeline defines how to handle the Http Request.
	-appsetting.json
		-Configuration file that contains the appsetting and connection string
	
	-wwwwroot
		-This folder is the default static files folder.
	-csproj file
		- contains the framework version and package information
		- 
			-Metapackage name is Microsoft.ASP.NetCore.App
	
	
	
	
	
	
	
	
	
	
	middleware 
	 can be created using 
		use() method,
			- used to create custom middleware.
			- It take a function as arg, that has two parameters 
		run() method,
			 request terminator -short circuit middleware,
		map() method
			used to execute a pipeline 
		mapwhen() method 
		
	built in middleware
		- useDeveloperExceptionPage()
		- UseExceptionHandler()
		- UseHsts()
			- Enable 
		- UseHttpRedirect()
			- Automaticaly redirect all Http request to Https
		- UseCookiePolicey()
			-Adds one layer of security for cookie usage.
			- asks the user to allow or deny cookie creation.
		- UseMvc()
			-Execute the controller action based on route request.
			- checks the route table and decides which controller and action need to be executed.
			- Routing url templates can be defined in the middleware.
			-UseMvccWithDefaultRoute() applies a middleware with default route templates.
			- UseMvc() applies a routing middleware that allows custom routing templated.
		- UseStaticFiles()
			- Is required to serve the static files for application.
			- Default static file folder is wwwwroot.
			- this can be used multiple time in a request pipeline.
			- Use parameters to define static file directories and options other than wwwroot.
		- UseDirectoryBrowser()
		- UseDefaultFiles()
		- UseFileServer()
		
	
	
	
	
	
Services
	- Services are reusable codein an applications
	- Services need to be registered in configureservice method of startup class
	- .Net code DI system creates and inject the instance of a service where ever is required.
	- IOC container will take care of the object life time scope.
	- services are registered in ServiceCollection object (services)
	- Services can be registered with the following scope and life time:
		-singleton
			- A single instance of service is created and maintained till the end of application.
			- services.AddSingleton() method to register a service as singleton.			
		-Scoped
			- A single instance per request scope.
		- Transient
			- It creates a new instance everytime wherever it is requested.
			- short lived objects.
		-Built-in DI system can be replaced by third party IoC containers (eg:Autofac)
		
-Configuration Sources
	- Configuration means that parameters passed to the application for execution.
	- Such a application settings, Connection string etc.
	- passed a key-value pair format.
	- we have many configuration sources in .Net core App:
		- Command line Arguments
		- Environment variable
		- AppSettings.json
		- XML files
		- ini files
		- Key per file.
		- Azure Key vault.
		- in memory collection.
	- when the default web host builder creates a web host it comes with some preconfigured configuration sources such as 
	cmd line args, Env variables and appsetting.json
	
	
	ASP.NET MVC
		-Every controller inherits from controller.
		- Every action has return type of IActionResult.
		- In attribute routing the [RoutePrefix] is replaced by [Route] attribute.
		- Action selector (HttpGet, HttpPost) attribute can be used for defining URI action.
		- tag helpers
			 - A tag helper is a c# class that can be used to create custom tags and attributes.
			 - While rendering the page Taghelper will be converted into HTML element.
			 - Asp.Net core provides a set of built-in tag helper we can x
			 
	 Caching in Asp.NET
		 -used for application performance improvement
		 - instead of regenerating the data or response we can store the data and response in storage for a temporary period of time.
		 - caching methods in ASP.NET
				-Response cache in .NET core we use ResponseCache attribute to cache a action response.
				- In-memory data caching
						- locally cache the data within the applicaton macchine.
						- this is not reliable, because if app crashed the cach will expire.
						- Add In emeory cache service to the service collection by calling AddMemoryCache()
						- Inject the IMemoryCache in the controller to get access to the cache object.
				- Distributed caching	
					- which stores the cache data outside the application.
					- We can use SqlServer or Redis server to cache data.
					- We use IDistributedCache interface to get access to the distributed cache service.
						Distributed cache provider:
							- InMemory DistributedCache.
									- Only for development purpose, not for production.
							- SqlServer DistributedCache.
								- dotnet sql-cache create "Data source=(localdb)
							- Redis DistributedCache.
		

		state managment
			- Query string -not ccoered
			- hidden fields
			- cookiess
			-session
				- BY default not enabled.
				- one of the disribution cache must be enabled to use session
				- session data is stored in 
			- temp data
				- Asp.net core provides two templates providers:
					- cookie based provider 
					- session based provider
			- DI
			- caching
			- HttpContext.Items
			
	- .net Core App deployment type
		- FDD Framework dependent deployment
			-dotnet app.dll
			- shar ed library and framework are not a part of app deploymnet
			- runtime must be installed in macchine
			- application can be run using "dotnet mydll" command
			
		- SCD Self-contained Deployment
			- runtimeis also published into the deployment folder
			- No runtime require in the macchine
			- Specify the RID in csproj file
				<RuntimeIdentifiers>Win10-x64</RuntimeIdentifiers>
			- publish using the following command
				syntax: dotnet publish -c Release -r <rid-value>
				eg. dotnet publish -c release -r win10-x64
			
		- FDE Framework dependent Executables
	
			Shared libraries and framework are not a part of app deployment
			runtime must be installed in the macchine
			it creates a self executeable file in the publish folder.
			it can be run directly by command prompt or double click.

Entity framework core
	- Entity classes and DBContext class
	configure the DBContext service in configureServices method
	for production we use sql server as database
	database sources
	-In-memeory
	
			
			
			
			
Docker
	-Images
		
		contaniser application is called image.
		image is used to create instance of applicaion.
		the running instnace is called conatiner.
		every conatiner has an unique name and id.
		every image also has a unique name and id
		image name must be in <imagename>:<tag> format
			-tag is a version identifier ar unique value that can be used to identify image
			eg: eshop-web:1.0
				eshop-web:2.0
				eshop-web:3.0
				
			if tag name is not supplied at the time of image creation, it will be assigned to 'latest' by default
			eg: eshop-web: latest
			
			-an image contains a set of layers.
				every layer has unique id
			Repositories (registries)
				-Is a storage place for code and data.
				- a docker image repository is a place to store images.
				- Repositories can be local and cloud
					Local
						- store locally in Dev machine.
						- local repo images name can be anything, without repo name
					cloud 
						- publically accessible repository
						- anyone can access it from here
						there are two types:
							- private and public repository
							
							- when uploading to a public repo it is accessible to all without any credential
								eg: docker hub is a public repository
								
							Private
								- Secured repository
								- it needs credentials to push and pull images
								- Azure container registry(ACR), Elastic container registry(ECR) ,
List of docker command								
	docker images
		- list all images located in local repo
		
	docker run -p host-port:container-port -d --name "name of container" --rm imagename
		--name = used to assign a name for running container. if not used docker will assign random name to container
		-d = detach mode
		--rm = remove the container when stopped 
		-p = map host machine port number to container app port.
	
	docker ps
		- list all running containers
	docker stop <containerID>/<container name>
		- stop the running container
	
	docker ps -all 
		- list all the runnning and stopped container
	
	docker rm <containerId/Container name>
		-removed the stopped conatiner
		
	docker rm <containerId/Container name>
		-removed the stopped conatiner	
		
	
	Building images 
		- A aset of commands need to be executed
		- command can be written into a file called "DockerFile"
		- the instruction to build an image may start with the following keywords:
		 
		 FROM <base imagename>
				- specify the base image for our application.
				-  eq: FROM nginx:latest
		
		-LABEL <key>=<value>
			used to ass meta information for image, such as author life, version, company etc.
			-LABEL  author "Chandan"
			- LABEL version 1.2.0
			
			
		- RUN <cmd><args>
		
		-	execute a coommand while building the image.
		-	run dotnet restore && dotnet build &&dotnet publish
		              
			
		WORKDIR<dir_path>
			- set the current working directory inside the container.
			- WORKDIR /user/app
			- WORKDIR C:\Users\myapp
			
		COPY [-from <stage>|<source file/pattern> <dest_path>
			- copy files from local machine to docker image path		
			- COPY ./*.jpg /user/app/
		
		-ENV <envvariablename> <value>
			-used to set the envronment variable value for the app.
			
		-PORT <port-number>
			- specify the port no to opened
			
		-CMD <command> <args>
			- Execute commands when the container is created.
			- when image is running
			
		 - ENTRYPOINT <cmd> <args>
			- Execute command when the container is created.
			
			
	Building docker image
	-docker build -t <imagename:tag> docker <file path location>
	eg: docker build -t mysampleapp:v1 . (. if the docker file is present in same location from where you are running)
	
	-containerizing .net core apps
		-Download SDK and runtime images
		
		
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			